#!/usr/bin/env python
# -*- coding: utf-8 -*-

#############################################################################
##                                                                         ##
##                                                                         ##
## Copyright (C) 2015 ADS CyberSecurity. All rights reserved.              ##
## This document is the property of ADS CyberSecurity, it is               ##
## licensed under the Apache Open Source License                           ##
##                                                                         ##
##  Author: Andy Dove <andrew.dove@airbus.com>                             ##
##                                                                         ##
#############################################################################

"""
@author:       Andy Dove
@contact:      andrew.dove@airbus.com
@organization: Airbus Defence and Space CyberSecurity
"""

import os
from optparse import OptionParser

p = OptionParser()
p.add_option('-f','--file', dest='filename', help='File to decrypt', metavar='FILE')
p.add_option('-k','--key', dest='key', help='Cypher key', metavar='KEY')
p.add_option('-o','--out', dest='outfile', help='Output file', metavar='FILE')
(options,args) = p.parse_args()

fileName = options.filename
if(not os.path.isfile(fileName)):
	print "Input file does not exist."
	exit()
else:
	data = bytearray(open(fileName,'rb').read())
key = options.key
outFile = options.outfile

def Decrypt(data, key):
	KeyLength = len(key)
	seed = 77 % KeyLength
	CurrentPos = 0
	step = 0
	while(CurrentPos < len(data)):
		CurrByte = data[CurrentPos]
		CurrByte = CurrByte + seed
		CurrByte = CurrByte ^ ord(key[seed % KeyLength])
		CurrByte = CurrByte ^ ord(key[step % KeyLength])
		CurrByte = CurrByte & 0xFF
		data[CurrentPos] = CurrByte
	
		Nextseed = seed + 1
		if(step % KeyLength == 0):
			Nextseed = 0
		seed = Nextseed
		CurrentPos = CurrentPos + 1
		step = step + 1	
	# In some of the test cases the first byte only comes out inccorect, 
	# test for a PE signature and if present ensure first byte will be 'M'
	if(str(data[0xE8:0xEA]) == 'PE'):
		data[0] = 0x4D
		return data
	else:
		print "Unable to decrypt file."
		return None

decryptedData = Decrypt(data,key)
if(decryptedData == None):
	exit()
	
if(outFile == None):
	print decryptedData
else:
	f = open(outFile,'wb')
	f.write(decryptedData)
	f.flush()
	f.close()
	
